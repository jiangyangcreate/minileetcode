[
  {
    "title": "后缀表达式",
    "description": "后缀表达式，又称逆波兰式，指的是不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则）。\r\n\r\n例如：后缀表达式为“2 3 + 4 × 5 -”计算过程如下：\r\n（1）从左至右扫描，将 2 和 3 压入堆栈；\r\n（2）遇到 + 运算符，因此弹出 3 和 2（ 3 为栈顶元素，2 为次顶元素，注意与前缀表达式做比较），计算出 3+2 的值，得 5，再将 5 入栈；\r\n（3）将 4 入栈；\r\n（4）接下来是 × 运算符，因此弹出 4 和 5，计算出 4 × 5 = 20，将 20 入栈；\r\n（5）将 5 入栈；\r\n（6）最后是-运算符，计算出 20-5 的值，即 15，由此得出最终结果。\r\n\r\n示例\r\n\r\nlistx = [15, 7, 1, 1, \"+\", \"-\", \"/\", 3, \"*\", 2, 1, 1, \"+\", \"+\", \"-\"]",
    "python_code": "# 方法1-python人思维\r\nwhile len(listx) > 1:\r\n    print(listx)\r\n    for i in range(len(listx)):\r\n        if str(listx[i]) in '+-*/':\r\n            if listx[i] == '+':\r\n                new = listx[i-2] + listx[i-1]\r\n            if listx[i] == '-':\r\n                new = listx[i-2] - listx[i-1]\r\n            if listx[i] == '*':\r\n                new = listx[i-2] * listx[i-1]\r\n            if listx[i] == '/':\r\n                new = listx[i-2] / listx[i-1]\r\n            del listx[i]\r\n            del listx[i-1]\r\n            listx[i-2] = new\r\n            break\r\nprint(listx)\r\n\r\n# 方法2-利用pop 和 append 仿c语言栈操作\r\nlisty = []\r\nfor i in listx:\r\n    if str(i) not in \"+-*/\":\r\n        listy.append(i)  # 入栈\r\n    else:\r\n        if i == \"+\":\r\n            new = listy.pop() + listy.pop()  # 出栈\r\n        if i == \"-\":\r\n            new = listy.pop() - listy.pop()\r\n        if i == \"*\":\r\n            new = listy.pop() * listy.pop()\r\n        if i == \"/\":\r\n            new = listy.pop() / listy.pop()\r\n        listy.append(new)\r\nprint(listy)",
    "level": "easy"
  },
  {
    "title": "求解密码",
    "description": "Python中的string模块包含了许多字符，请根据以下提示设计一个函数：\r\n\r\n参数1：不同的密码组合类型\r\n参数2：密码长度\r\n\r\n输出：所以可能的组合数量\r\n\r\n示例：当仅用**小写字母**和**数字**来组成1位密码时，共有36种可能（26+10）\r\n\r\nstring.ascii_letters 所有字母\r\nstring.ascii_uppercase  大写字母\r\nstring.ascii_lowercase  小写字母\r\nstring.digits   数字\r\nstring.punctuation  标点符号\r\nstring.printable    可打印字符\r\nstring.whitespace   空白字符",
    "python_code": "import string\r\n# 方法1 正常Python人思维\r\ndef generate_pwd_list(dic, max_len):\r\n    \"\"\"\r\n    description:生成指定长度的密码序列\r\n    param {*} dic   字典\r\n    param {*} pwd_len   最大密码长度\r\n    return {*}\r\n    \"\"\"\r\n    k = itertools.product(dic, repeat=max_len)  # 迭代器\r\n    allkey = (\"\".join(i) for i in k)\r\n    if max_len == 1:\r\n        return list(allkey)\r\n    return generate_pwd_list(dic, max_len - 1) + list(allkey)\r\n\r\n\r\nkeys = generate_pwd_list(string.ascii_lowercase + string.digits, 1)\r\nprint(len(keys))\r\n\r\n\r\n# 方法2 递归\r\ndef combi(seq):\r\n    if not seq:\r\n        yield []\r\n    else:\r\n        for element in seq[0]:\r\n            for rest in combi(seq[1:]):\r\n                yield [element] + rest\r\n\r\n\r\ndef sets(dic, pwd_len):\r\n    n = []\r\n    for i in range(pwd_len):\r\n        n.append(dic)\r\n    return list(combi(n))\r\n\r\n\r\nprint(len(sets(string.ascii_lowercase + string.digits, 2)))\r\n\r\n\r\n\r\n# 方法3 迭代器\r\n\r\n\r\nres = []\r\n\r\n\r\ndef func(arr, index, temp):\r\n    if len(temp) == len(arr):\r\n        res.append(temp[:])\r\n    else:\r\n        for i in range(len(arr[index])):\r\n            temp.append(arr[index][i])\r\n            func(arr, index + 1, temp)\r\n            temp.pop()\r\n\r\n\r\ndef sets(dic, pwd_len):\r\n    n = []\r\n    for i in range(pwd_len):\r\n        n.append(dic)\r\n    func(\r\n        n,\r\n        0,\r\n        [],\r\n    )\r\n\r\n\r\nsets(string.ascii_lowercase + string.digits, 2)\r\nprint(len(res))",
    "level": "easy"
  },
  {
    "title": "质数分解",
    "description": "每个数字可以写成多个质数的乘积，给定一个数字，请你分解为多个质数",
    "python_code": "def fun(num, list=None):\r\n    if list is None:\r\n        list = []\r\n    for i in range(2, num):\r\n        while num % i == 0:\r\n            list.append(i)\r\n            num = int(num / i)\r\n            if num > 1:\r\n                fun(num)\r\n    return list\r\nx = 9*5\r\nprint(fun(x))",
    "level": "easy"
  },
  {
    "title": "九九乘法表",
    "description": "要求使用循环代码打印一个九九乘法表出来.如下\r\n\r\n```bash\r\n1*1=1 \r\n\r\n1*2=2 2*2=4 \r\n\r\n1*3=3 2*3=6 3*3=9 \r\n\r\n1*4=4 2*4=8 3*4=12 4*4=16 \r\n\r\n1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 \r\n\r\n1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 \r\n\r\n1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 \r\n\r\n1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64        \r\n\r\n1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 \r\n```",
    "python_code": "#方法一\r\nfor i in range(1,10):\r\n    print()\r\n    for j in range(1,i+1):\r\n        print('%d*%d=%d' % (j,i,i*j),end=' ')\r\n\r\n#方法二\r\ni=1\r\nwhile i<10: #控制行，1到9\r\n    j=1\r\n    while j <= i: #控制每行显示的数量，1到9\r\n        print(\"%d*%d=%d\"%(j,i,i*j),end=' ') #输出\r\n        j+=1 #每行显示的数量加1\r\n    print(\"\\n\") #每一行结束换行\r\n    i+=1 #行数加1",
    "level": "easy"
  },
  {
    "title": "字典排序",
    "description": "将字典数组按字典的某个key排序",
    "python_code": "# 方法1：\r\nsorted(d.cop(),key = lambda i:i[k])\r\n\r\n# 方法2：\r\nheappush(h,(i[k],i)) for i in d",
    "level": "easy"
  },
  {
    "title": "冒泡排序",
    "description": "给定一个列表，请你对列表的元素进行     从大到小排序   与从小到大排序",
    "python_code": "list1 = [13, 22, 6, 99, 11, 0]\r\n\r\nfor a in range(len(list1)):\r\n    for b in range(a,len(list1)):\r\n        if list1[a] < list1[b]:  #如果m大于了n\r\n           list1[a] ,list1[b] =  list1[b],list1[a]#交换位置\r\nprint(list1)",
    "level": "easy"
  },
  {
    "title": "快速排序",
    "description": "快速排序（Quicksort）是对冒泡排序的一种改进算法。\r\n\r\n该算法的实现基本可分为以下几步：\r\n\r\n在数组中选一个基准数（通常为数组第一个）。\r\n将数组中小于基准数的数据移到基准数左边，大于基准数的移到右边\r\n对于基准数左、右两边的数组，不断重复以上两个过程，直到每个子集只有一个元素，即为全部有序。\r\n\r\n请你编写它的实现代码。",
    "python_code": "def partition(arr, low: int, high: int):\r\n    pivot, j = arr[low], low  # 获取底部元素与 对应的初始下标\r\n\r\n    for i in range(low + 1, high + 1):  # 从第2个元素开始，到最后一个元素\r\n        if arr[i] <= pivot:  # 如果这个元素，小于第1个元素\r\n            j += 1  # 初始下标+1\r\n            arr[j], arr[i] = arr[i], arr[j]  # 把这个小元素和标的元素换位置\r\n    arr[low], arr[j] = arr[j], arr[low]  # arr[low]是等于自己的，现在把他挪到中间位置\r\n    return j  # 返回这个中间位置\r\n\r\n\r\ndef quick_sort_between(arr, low: int, high: int):\r\n    if high-low <= 1:  # 递归结束条件\r\n        return\r\n\r\n    m = partition(arr, low, high)\r\n    quick_sort_between(arr, low, m - 1) # 二分后自我调用，直到递归结束条件触发\r\n    quick_sort_between(arr, m + 1, high)\r\n\r\n\r\ndef quick_sort(arr):\r\n    \"\"\"\r\n    快速排序(in-place)\r\n    :param arr: 待排序的List\r\n    :return: 快速排序是就地排序(in-place)\r\n    \"\"\"\r\n    quick_sort_between(arr, 0, len(arr)-1)  # arr[0] - arr[len(arr)-1]\r\n\r\n# 测试数据\r\nif __name__ == '__main__':\r\n    arr = [17, 56, 71, 38, 61, 62, 48, 28, 57, 42, 10, 21, 12, 90]  # 长度为10\r\n    quick_sort(arr)\r\n    print(\"快速排序结果：\", arr)",
    "level": "easy"
  },
  {
    "title": "抽奇数",
    "description": "要求：0-N，每次抽走奇数，打印剩余的那个数字",
    "python_code": "aList = []\r\nfor i in range(0,2023):\r\n    aList.append(i)\r\n\r\nwhile len(aList)>1:\r\n    aList = aList[1::2]\r\n    print(aList)\r\nprint(aList)",
    "level": "easy"
  },
  {
    "title": "平方和",
    "description": "两个数字的平方和是2022，请问这2个数分别是多少",
    "python_code": "for a in range(1,2022):\r\n    if (2022 - a*a)**0.5 in range(1,2022):\r\n        print(a)",
    "level": "easy"
  },
  {
    "title": "规整的打印考场号",
    "description": "学校有440人参加考试，1号考场有80个座位，要求座位号为0101--0180\r\n后面每个考场40个座位：\r\n2号考场考试号要求为0201--0240\r\n3号考场考试号要求为0301--0440\r\n后续考场以此类推，请你打印出来这些考场号吧",
    "python_code": "for i in range(1,440):\r\n    if i <= 80 :\r\n        print('01{:0>2d}'.format(i))\r\n    elif i <= 440:\r\n        if i%40 == 0:\r\n            print('{:0>2d}{:0>2d}'.format(i//40-1,40))\r\n        else:\r\n            print('{:0>2d}{:0>2d}'.format(i//40,i%40))",
    "level": "easy"
  },
  {
    "title": "打印时间",
    "description": "请从00:00依次打印出一天的时间\r\n示例：\r\n\r\n- 23 : 52\r\n- 23 : 53\r\n- 23 : 54",
    "python_code": "for 时钟 in range(24):\r\n    for 分钟 in range(60):\r\n        print(时钟, ':', 分钟)",
    "level": "easy"
  },
  {
    "title": "数羊问题",
    "description": "编写一段代码，模拟我们数羊到入睡的过程：\r\n每数五只羊，就提问一次：睡着了吗？\r\n如果没有睡着，继续循环，并打印“继续数羊”。\r\n如果睡着了，则停止循环，并打印“终于睡着了”。",
    "python_code": "i = 0\r\nwhile True:\r\n    i += 1\r\n    left_endpoint = 1 + 5 * ( i - 1 )\r\n    right_endpoint = 1 + 5 * i\r\n    for i in range(left_endpoint, right_endpoint):\r\n        print(str(i)+'只羊')\r\n    answer = input('睡着了吗？回答是或否：')\r\n    if answer == '是':\r\n        break\r\n    print('继续数羊')\r\nprint('终于睡着了')\r\n\r\n#方法二\r\n睡觉的状态 = '还没睡'\r\na = 0\r\nwhile 睡觉的状态 != '睡着': # 只要不是睡着，就继续数\r\n    a +=1\r\n    print(str(a)+'只羊')\r\n    if a%9 == 0 : # %是取余数 每次数5只羊\r\n        睡觉的状态 = input('睡着了嘛？')",
    "level": "easy"
  },
  {
    "title": "图书馆系统",
    "description": "创建一个图书馆系统，要求如下：\r\n\r\n1. 有两个类：用户类和图书类\r\n2. 用户类有属性：姓名、年龄、性别、借书数量、借书列表\r\n3. 图书类有属性：书名、作者、出版社、价格、状态（是否被借出）\r\n4. 用户类有方法：借书、还书\r\n5. 图书类有方法：借出、归还\r\n6. 用户类和图书类的方法中，需要对用户的借书数量和图书的状态进行判断\r\n7. 用户类和图书类的方法中，需要对用户的借书列表和图书的状态进行修改\r\n8. 用户类和图书类的方法中，需要打印出用户的借书列表和图书的状态\r\n9. 使用图形化界面工具，如tkinter\r\n安装命令 pip install tkinter-page",
    "python_code": "from tkinter import *\r\n\r\n\"\"\"\r\n提前安装好模块:pip install tkinter-page\r\n需要掌握的知识：Python基础、Mysql命令、os模块、tkinter模块\r\n\"\"\"\r\nfrom tkinter import *\r\nimport sqlite3\r\nimport os\r\n\r\n\r\nclass db:\r\n    def addmysql(name, author, comment, state):  # 添加数据\r\n        Desktoppath = \"./StrayLibrary/book.db\"\r\n        db = sqlite3.connect(Desktoppath)  # 使用cursor()方法获取操作游标\r\n        cursor = db.cursor()  # SQL 插入语句\r\n        sql = \"INSERT INTO EMPLOYEE(name,author,comment,state)VALUES ('{}','{}','{}','{}')\".format(\r\n            name, author, comment, state\r\n        )\r\n        try:  # 执行sql语句\r\n            cursor.execute(sql)  # 提交到数据库执行\r\n            db.commit()\r\n        except:  # Rollback in case there is any error\r\n            db.rollback()\r\n        db.close()  # 关闭数据库连接\r\n\r\n    def changemysql(state, name):  # 更改数据状态\r\n        Desktoppath = \"./StrayLibrary/book.db\"\r\n        db = sqlite3.connect(Desktoppath)\r\n        cursor = db.cursor()  # 使用cursor()方法获取操作游标\r\n        sql = \"UPDATE EMPLOYEE SET state = '%s' where name = '%s' \" % (state, name)\r\n        try:\r\n            cursor.execute(sql)\r\n            db.commit()\r\n        except:\r\n            pass\r\n        db.close()\r\n\r\n    def checkmysql():  # 检索数据库\r\n        Desktoppath = \"./StrayLibrary/book.db\"\r\n        db = sqlite3.connect(Desktoppath)\r\n        cursor = db.cursor()  # 使用cursor()方法获取操作游标\r\n        sql = \"SELECT * FROM EMPLOYEE\"  # SQL 查询语句\r\n        try:\r\n            cursor.execute(sql)  # 获取所有记录列表\r\n            results = cursor.fetchall()\r\n            return results\r\n        except:\r\n            pass\r\n        db.close()\r\n\r\n    def bulildmysql():\r\n        try:\r\n            os.makedirs(\"./StrayLibrary\")  # 创建一个文件夹\r\n            Desktoppath = \"./StrayLibrary/book.db\"  # 文件夹下创建一个数据库\r\n            file = open(Desktoppath, \"w\")\r\n            file.close()\r\n\r\n            db = sqlite3.connect(Desktoppath)\r\n            cursor = db.cursor()  # 使用cursor()方法获取操作游标\r\n            cursor.execute(\r\n                \"DROP TABLE IF EXISTS EMPLOYEE\"\r\n            )  # 如果数据表已经存在使用 execute() 方法删除表。\r\n            sql = \"\"\"CREATE TABLE EMPLOYEE (name  TEXT(255),author  TEXT(255),comment TEXT(255),state TEXT(255))\"\"\"\r\n            cursor.execute(sql)  # 创建数据表SQL语句\r\n            db.close()\r\n            db.addmysql(\r\n                \"惶然录\", \"费尔南多·佩索阿\", \"一个迷失方向且濒于崩溃的灵魂的自我启示、一首对默默无闻、失败、智慧、困难和沉默的赞美诗。\", \"未借出\"\r\n            )\r\n            db.addmysql(\r\n                \"以箭为翅\", \"简媜\", \"调和空灵文风与禅宗境界，刻画人间之缘起缘灭。像一条柔韧的绳子，情这个字，不知勒痛多少人的心肉。\", \"未借出\"\r\n            )\r\n            db.addmysql(\r\n                \"心是孤独的猎手\", \"卡森·麦卡勒斯\", \"我们渴望倾诉，却从未倾听。女孩、黑人、哑巴、醉鬼、鳏夫的孤独形态各异，却从未退场。\", \"已借出\"\r\n            )\r\n        except:\r\n            pass\r\n\r\n\r\nclass Book:\r\n    def __init__(self, name, author, comment, state):\r\n        self.name = name\r\n        self.author = author\r\n        self.comment = comment\r\n        self.state = state\r\n\r\n    def __str__(self):\r\n        return \"\\n名称：《%s》 \\n作者：%s \\n推荐语：%s\\n状态：%s \\n---------\" % (\r\n            self.name,\r\n            self.author,\r\n            self.comment,\r\n            self.state,\r\n        )\r\n\r\n\r\nclass StrayLibrary:\r\n    books = []\r\n\r\n    def __init__(self, init_window_name):\r\n        self.init_window_name = init_window_name\r\n        results = db.checkmysql()\r\n        for row in results:\r\n            name = row[0]\r\n            author = row[1]\r\n            comment = row[2]\r\n            state = row[3]\r\n            book1 = Book(name, author, comment, state)\r\n            self.books.append(book1)\r\n\r\n    def set_init_window(self):  # 设置窗口\r\n        self.init_window_name.title(\"流浪图书馆(StrayLibrary)\")  # 窗口名\r\n        self.init_window_name.geometry(\"450x260+10+10\")\r\n        self.result_data_Text = Text(\r\n            self.init_window_name, width=35, height=15\r\n        )  # 处理结果展示\r\n        self.result_data_Text.grid(row=1, column=12, rowspan=7, columnspan=7)\r\n\r\n        self.mianbutton1 = Button(\r\n            self.init_window_name,\r\n            text=\"查询(check)\",\r\n            bg=\"DodgerBlue\",\r\n            width=20,\r\n            command=self.show_all_book,\r\n        )  # 调用内部方法  加()为直接调用\r\n        self.mianbutton2 = Button(\r\n            self.init_window_name,\r\n            text=\"添加(add)\",\r\n            bg=\"DodgerBlue\",\r\n            width=20,\r\n            command=self.add_book,\r\n        )  # 调用内部方法  加()为直接调用\r\n        self.mianbutton3 = Button(\r\n            self.init_window_name,\r\n            text=\"借阅(lend)\",\r\n            bg=\"DodgerBlue\",\r\n            width=20,\r\n            command=self.lend_book,\r\n        )  # 调用内部方法  加()为直接调用\r\n        self.mianbutton4 = Button(\r\n            self.init_window_name,\r\n            text=\"归还(return)\",\r\n            bg=\"DodgerBlue\",\r\n            width=20,\r\n            command=self.return_book,\r\n        )  # 调用内部方法  加()为直接调用\r\n        self.mianbutton1.grid(row=1, column=11)\r\n        self.mianbutton2.grid(row=3, column=11)\r\n        self.mianbutton3.grid(row=5, column=11)\r\n        self.mianbutton4.grid(row=7, column=11)\r\n\r\n    # 功能函数\r\n    def show_all_book(self):\r\n        self.result_data_Text.delete(0.0, END)\r\n        for book in self.books:\r\n            self.result_data_Text.insert(1.0, book)\r\n\r\n    def add_book(self):\r\n        top = Tk()\r\n        top.title(\"添加(add)\")\r\n        top.geometry(\"300x120+450+10\")\r\n        self.L1 = Label(top, text=\"请输入书籍名称：\")\r\n        self.E1 = Entry(top, bd=5)\r\n        self.L2 = Label(top, text=\"请输入作者名称：\")\r\n        self.E2 = Entry(top, bd=5)\r\n        self.L3 = Label(top, text=\"请输入书籍推荐语：\")\r\n        self.E3 = Entry(top, bd=5)\r\n        self.L1.place(x=0, y=0)\r\n        self.L2.place(x=0, y=30)\r\n        self.L3.place(x=0, y=60)\r\n        self.E1.place(x=120, y=0)\r\n        self.E2.place(x=120, y=30)\r\n        self.E3.place(x=120, y=60)\r\n        self.B = Button(top, text=\"输入完毕请点击确认,无需继续输入请关闭窗口\", command=self.add_booking)\r\n        self.B.pack(side=BOTTOM)\r\n\r\n    def add_booking(self):\r\n        new_name = self.E1.get()\r\n        new_author = self.E2.get()\r\n        new_comment = self.E3.get()\r\n        self.result_data_Text.delete(0.0, END)\r\n        new_book = Book(new_name, new_author, new_comment, \"未借出\")\r\n        self.books.append(new_book)\r\n        db.addmysql(new_name, new_author, new_comment, \"未借出\")  # 写入数据库\r\n        self.result_data_Text.insert(1.0, new_name + \"录入成功！\\n\")\r\n\r\n    def check_book(self, name):\r\n        for book in self.books:\r\n            if book.name == name:\r\n                return book\r\n        else:\r\n            return None\r\n\r\n    def lend_book(self):\r\n        toplend = Tk()\r\n        toplend.title(\"借阅(lend)\")\r\n        toplend.geometry(\"330x50+450+30\")\r\n        self.lendE1 = Entry(toplend, bd=5)\r\n        self.lendE1.pack(side=RIGHT)\r\n        self.lendB1 = Button(toplend, text=\"输入书名，输入完毕请点击\", command=self.lend_booking)\r\n        self.lendB1.pack(side=LEFT)\r\n\r\n    def lend_booking(self):\r\n        name = self.lendE1.get()\r\n        res = self.check_book(name)\r\n        self.result_data_Text.delete(0.0, END)\r\n        if res != None:\r\n            if res.state == \"已借出\":\r\n                self.result_data_Text.insert(1.0, \"你来晚了一步，这本书已经被借走了噢\")\r\n            else:\r\n                res.state = \"已借出\"\r\n                db.changemysql(\"已借出\", res.name)\r\n                self.result_data_Text.insert(1.0, \"借阅成功，借了不看会变胖噢～\")\r\n        else:\r\n            self.result_data_Text.insert(1.0, \"这本书暂时没有收录在系统里呢\")\r\n\r\n    def return_book(self):\r\n        topreturn = Tk()\r\n        topreturn.title(\"归还(return)\")\r\n        topreturn.geometry(\"330x50+450+30\")\r\n        self.returnE1 = Entry(topreturn, bd=5)\r\n        self.returnE1.pack(side=RIGHT)\r\n        self.returnB1 = Button(\r\n            topreturn, text=\"输入书名，完毕请点击\", command=self.return_booking\r\n        )\r\n        self.returnB1.pack(side=LEFT)\r\n\r\n    def return_booking(self):\r\n        name = self.returnE1.get()\r\n        res = self.check_book(name)  # 调用check_book方法，将返回值赋值给变量res\r\n        self.result_data_Text.delete(0.0, END)\r\n        if res == None:  # 如果返回的是空值，即这本书的书名不在系统里\r\n            self.result_data_Text.insert(1.0, \"没有这本书噢，你恐怕输错了书名～\")\r\n        else:  # 如果返回的是实例对象\r\n            if res.state == \"未借出\":  # 如果实例属性state等于0，即这本书的借阅状态为'未借出'\r\n                self.result_data_Text.insert(1.0, \"这本书没有被借走，在等待有缘人的垂青呢！\")\r\n            else:  # 如果实例属性state等于1，即状态为'已借出'\r\n                self.result_data_Text.insert(1.0, \"归还成功！\")\r\n                res.state = \"未借出\"  # 归还后书籍借阅状态为0，重置为'未借出'\r\n                db.changemysql(\"未借出\", res.name)\r\n\r\n\r\ndef gui_start():\r\n    db.bulildmysql()\r\n    init_window = Tk()  # 实例化出一个父窗口\r\n    ZMJ_PORTAL = StrayLibrary(init_window)  # 设置根窗口默认属性\r\n    ZMJ_PORTAL.set_init_window()\r\n    init_window.mainloop()  # 父窗口进入事件循环，可以理解为保持窗口运行，否则界面不展示\r\n\r\n\r\ngui_start()",
    "level": "medium"
  },
  {
    "title": "读取BMP文件",
    "description": "不使用第三方模块的前提下，完成对24位bmp图像的图像数据分析与像素读取。\r\n程序设计需要体现面向对象编程的特点，以创建类的形式编写。\r\n\r\n参考资料：\r\n\r\n以一张2*2的24位图的bmp格式图片为例\r\n\r\n| Offset | Offset10 | Size | Hex value | Value | Description |\r\n|---|---|---|---|---|---|\r\n| BMP Header |  |  |  |  |  |\r\n| 0h | 0 | 2 | 42 4D | \"BM\" | ID field \\(42h, 4Dh\\) |\r\n| 2h | 2 | 4 | 46 00 00 00 | 70 bytes \\(54\\+16\\) | BMP 文件的大小（54 字节标头 \\+ 16 字节数据） |\r\n| 6h | 6 | 2 | 00 00 | Unused | 特定应用 |\r\n| 8h | 8 | 2 | 00 00 | Unused | 特定应用 |\r\n| Ah | 10 | 4 | 36 00 00 00 | 54 bytes \\(14\\+40\\) | 可以找到像素阵列（位图数据）的偏移量 |\r\n| DIB Header\\-Device Independent Bitmaps\\-设备无关位图 |  |  |  |  |  |\r\n| Eh | 14 | 4 | 28 00 00 00 | 40 bytes |  DIB 头中的字节数（从此时开始） |\r\n| 12h | 18 | 4 | 02 00 00 00 | 2 pixels \\(left to right order\\) | 位图的宽度（以像素为单位） |\r\n| 16h | 22 | 4 | 02 00 00 00 | 2 pixels \\(bottom to top order\\) | 位图的高度（以像素为单位）。从下到上的像素顺序为正。 |\r\n| 1Ah | 26 | 2 | 01 00 | 1 plane | 使用的颜色平面数量 |\r\n| 1Ch | 28 | 2 | 18 00 | 24 bits | 每个像素的位数 |\r\n| 1Eh | 30 | 4 | 00 00 00 00 | 0 | BI\\_RGB，未使用像素阵列压缩 |\r\n| 22h | 34 | 4 | 10 00 00 00 | 16 bytes | 原始位图数据的大小（包括填充） |\r\n| 26h | 38 | 4 | 13 0B 00 00 | 2835 pixels/metre horizontal | 图像的打印分辨率， |\r\n| 2Ah | 42 | 4 | 13 0B 00 00 | 2835 pixels/metre vertical | 72 DPI × 39\\.3701 inches per metre yields 2834\\.6472 |\r\n| 2Eh | 46 | 4 | 00 00 00 00 | 0 colors | 调色板中的颜色数量 |\r\n| 32h | 50 | 4 | 00 00 00 00 | 0 important colors | 0 表示所有颜色都很重要 |\r\n| Start of pixel array \\(bitmap data\\) |  |  |  |  |  |\r\n| 36h | 54 | 3 | 00 00 FF | 0 0 255 | Red, Pixel \\(x=0, y=1\\) |\r\n| 39h | 57 | 3 | FF FF FF | 255 255 255 | White, Pixel \\(x=1, y=1\\) |\r\n| 3Ch | 60 | 2 | 00 00 | 0 0 | Padding for 4 byte alignment \\(could be a value other than zero\\) |\r\n| 3Eh | 62 | 3 | FF 00 00 | 255 0 0 | Blue, Pixel \\(x=0, y=0\\) |\r\n| 41h | 65 | 3 | 00 FF 00 | 0 255 0 | Green, Pixel \\(x=1, y=0\\) |\r\n| 44h | 68 | 2 | 00 00 | 0 0 | Padding for 4 byte alignment \\(could be a value other than zero\\) |\r\n\r\nbit（位）比特是计算机运算的基础，属于二进制的范畴\r\n\r\nbyte字节是内存的基本单位\r\n\r\n8 bit = 1 byte\r\n\r\n```python\r\n# 参考知识\r\n\r\ndata = b'\\xff' # b代表这是一个二进制数据，\\x代表这是一个十六进制的数据\r\n\r\nbin_data = bin(int.from_bytes(data))[2:]  # -> 11111111\r\n\r\nint(bin_data, 2) # -> 255\r\n\r\n# 打开文件作为可编辑对象\r\nwith open(\"r.bmp\", \"rb\") as f:\r\n    d = f.read()\r\n    data = bytearray(d)\r\n# 试着把54到246的数据都改成0x00，即黑色。这样整张图片都变成黑色了\r\nfor i in range(54, 246):\r\n    data[i]= 0x00\r\n# 保存文件\r\nwith open(\"black.bmp\", \"wb\") as f:\r\n    f.write(data)\r\n```",
    "python_code": "class Readbmp:\r\n    \"\"\"\r\n    read bmp files\r\n    图片的格式说明：https://en.wikipedia.org/wiki/BMP_file_format#Example_1\r\n    \"\"\"\r\n\r\n    def __init__(self, pic_path) -> None:\r\n        self.pic_path = pic_path\r\n        self.read_color()\r\n\r\n    def read_color(self):\r\n        if self.pic_path.endswith(\".bmp\"):\r\n            self.read_bmp()\r\n        else:\r\n            print(\"不支持的格式\")\r\n\r\n    def read_bmp(self):\r\n        bin_datas = []\r\n        \"\"\"read file data to bin\"\"\"\r\n        with open(self.pic_path, \"rb\") as f:\r\n            while True:\r\n                if len(bin_datas) == f.tell():\r\n                    data = f.read(1)\r\n                    bindata = bin(int.from_bytes(data))[2:]\r\n                    if len(bindata) < 8:\r\n                        bindata = (8 - len(bindata)) * \"0\" + bindata\r\n                    bin_datas.append(bindata)\r\n                else:\r\n                    bin_datas = bin_datas[:-1]\r\n                    break\r\n\r\n        self.bin_pic_head = bin_datas[0:2]  # ID field\r\n        self.bin_pic_size = bin_datas[2:6]  # Size of the BMP file 文件大小\r\n        self.bin_pic_exe = bin_datas[6:10]  # 特定应用，默认为0\r\n        self.bin_pic_address = bin_datas[10:14]  # 图片信息开始地址\r\n        self.bin_pic_dib = bin_datas[14:18]  # DIB 头中的字节数\r\n        self.bin_pic_w = bin_datas[18:22]  # 图片像素宽度\r\n        self.bin_pic_h = bin_datas[22:26]  # 图片像素高度\r\n        self.bin_pic_color_num = bin_datas[26:28]  # 使用颜色平面数\r\n        self.bin_pic_color_long = bin_datas[28:30]  # 每个像素位数\r\n        self.bin_pic_bi = bin_datas[30:34]  # BI_RGB\r\n        self.bin_pic_big = bin_datas[34:38]  # 原始图像数据大小\r\n        self.bin_pic_printpix = bin_datas[38:42]  # 打印分辨率\r\n        self.bin_pic_dpi = bin_datas[42:46]  # DPI\r\n        self.bin_pic_color_num = bin_datas[46:50]  # 调色板中颜色数量\r\n        self.bin_pic_color_important = bin_datas[50:54]  # 重要颜色数量\r\n        self.bin_pic_data = bin_datas[54:]  # 图片数据\r\n        self.bin_to_pic()\r\n\r\n    # 将二进制数据转化成十进制数据\r\n    def bin_to_dec(self, bin_datas):\r\n        bin_data = \"\"\r\n        for i in reversed(bin_datas):\r\n            bin_data += i\r\n        return int(bin_data, 2)\r\n\r\n    # 将列表转为3个一组的二维列表\r\n    def change_data(self, data):\r\n        data_2d = []\r\n        x = []\r\n        for i in data:\r\n            x.append(int(i, 2))\r\n            if len(x) == 3:\r\n                data_2d.append(tuple(x))\r\n                x = []\r\n        return data_2d\r\n\r\n    # 处理图片数据\r\n    def bin_to_pic(self):\r\n        self.pic_head = chr(int(self.bin_pic_head[0], 2)) + chr(\r\n            int(self.bin_pic_head[1], 2)\r\n        )\r\n        self.pic_size = self.bin_to_dec(self.bin_pic_size)\r\n        self.pic_exe = self.bin_to_dec(self.bin_pic_exe)\r\n        self.pic_address = self.bin_to_dec(self.bin_pic_address)\r\n        self.pic_dib = self.bin_to_dec(self.bin_pic_dib)\r\n        self.pic_w = self.bin_to_dec(self.bin_pic_w)\r\n        self.pic_h = self.bin_to_dec(self.bin_pic_h)\r\n        self.pic_color_num = self.bin_to_dec(self.bin_pic_color_num)\r\n        self.pic_color_long = self.bin_to_dec(self.bin_pic_color_long)\r\n        self.pic_bi = self.bin_to_dec(self.bin_pic_bi)\r\n        self.pic_big = self.bin_to_dec(self.bin_pic_big)\r\n        self.pic_printpix = self.bin_to_dec(self.bin_pic_printpix)\r\n        self.pic_dpi = self.bin_to_dec(self.bin_pic_dpi)\r\n        self.pic_color_num = self.bin_to_dec(self.bin_pic_color_num)\r\n        self.pic_color_important = self.bin_to_dec(self.bin_pic_color_important)\r\n        self.pic_data = self.change_data(self.bin_pic_data)\r\n\r\n    # 打印图片信息\r\n    def show(self):\r\n        print(\r\n            \"\"\"\r\n文件ID  {} \r\n图像大小(Byte)  {}   \r\n特定应用  {}   \r\n图片信息开始地址  {}   \r\nDIB 头中的字节数 {}   \r\n图片像素宽度  {}   \r\n图片像素高度  {}   \r\n使用颜色平面数  {}   \r\n每个像素位数  {}   \r\nBI_RGB  {}   \r\n原始图像数据大小(Byte) {} \r\n打印分辨率  {}   \r\nDPI  {}   \r\n调色板中颜色数量  {}   \r\n重要颜色数量  {}   \r\n图片数据  {} .... {} \r\n\"\"\".format(\r\n                self.pic_head,\r\n                self.pic_size,\r\n                self.pic_exe,\r\n                self.pic_address,\r\n                self.pic_dib,\r\n                self.pic_w,\r\n                self.pic_h,\r\n                self.pic_color_num,\r\n                self.pic_color_long,\r\n                self.pic_bi,\r\n                self.pic_big,\r\n                self.pic_printpix,\r\n                self.pic_dpi,\r\n                self.pic_color_num,\r\n                self.pic_color_important,\r\n                self.pic_data[:5],\r\n                self.pic_data[-5:],\r\n            )\r\n        )\r\n\r\n    # 判断颜色\r\n    def color(self, color):\r\n        b, g, r = color[0], color[1], color[2]\r\n        if r == 0 and g == 0 and b == 0:\r\n            return \"黑色\"\r\n        elif r == 0 and g == 0 and b == 255:\r\n            return \"蓝色\"\r\n        elif r == 0 and g == 255 and b == 0:\r\n            return \"绿色\"\r\n        elif r == 255 and g == 0 and b == 0:\r\n            return \"红色\"\r\n        elif r == 255 and g == 255 and b == 255:\r\n            return \"白色\"\r\n        else:\r\n            return \"其他颜色\"\r\n\r\n    # 统计颜色\r\n    def count_color(self):\r\n        color_dict = {}\r\n        for i in self.pic_data:\r\n            if i in color_dict:\r\n                color_dict[i] += 1\r\n            else:\r\n                color_dict[i] = 1\r\n        return color_dict\r\n\r\n    # 判断颜色的比例\r\n    def color_percent(self):\r\n        color_dict = self.count_color()\r\n        color_percent_dict = {}\r\n        for i in color_dict:\r\n            color_percent_dict[self.color(i)] = int(\r\n                color_dict[i] / len(self.pic_data) * 100\r\n            )\r\n        for i in color_percent_dict:\r\n            print(\"{} 占比百分之 {}\".format(i, color_percent_dict[i]))\r\n\r\n\r\n\r\n\r\n\r\np = Readbmp(\"r.bmp\")  # 另存为新文件\r\np.color_percent()\r\n# 红色 占比百分之 100\r\n\"\"\"\r\nr.bmp是8*8的位图，其中有一个点是红色，其他都是黑色\r\n\"\"\"\r\n# 打开文件作为可编辑对象\r\nwith open(\"r.bmp\", \"rb\") as f:\r\n    d = f.read()\r\n    data = bytearray(d)\r\n# 试着把54到246的数据都改成0x00，即黑色。这样整张图片都变成黑色了（也可以只更改某个数据端）\r\nfor i in range(54, 246):\r\n    data[i]= 0x00\r\n# 保存文件\r\nwith open(\"rn.bmp\", \"wb\") as f:\r\n    f.write(data)\r\n\r\np = Readbmp(\"rn.bmp\")\r\np.show()\r\np.color_percent()\r\n# 黑色 占比百分之 100",
    "level": "medium"
  },
  {
    "title": "颜色量化",
    "description": "图片的颜色数量越多，图片就越难以压缩，图片的大小就越大，因此需要对图片进行颜色量化，减少图片的大小，将图像所需的颜色数量从96615减少到64，同时保持整体外观质量。\r\n\r\n图像来源`sklearn.datasets.load_sample_image(\"china.jpg\")`",
    "python_code": "# 导入核心模块\r\nfrom sklearn.datasets import load_sample_image\r\nfrom sklearn.cluster import KMeans\r\n\r\n# 导入辅助模块\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom sklearn.metrics import pairwise_distances_argmin\r\nfrom sklearn.utils import shuffle\r\n\r\n# 载入图片\r\nchina = load_sample_image(\"china.jpg\")\r\n\r\n# print(type(china)) # <class 'numpy.ndarray'>\r\n# print(china.shape) # (427, 640, 3)\r\n\r\n# 查看原图\r\nplt.figure(1)\r\nplt.clf()\r\nplt.axis('off')\r\nplt.title('Original image (96,615 colors)')\r\nplt.imshow(china)\r\n\r\n# 设定K值\r\nn_colors = 64\r\n\r\n# 训练数据\r\nkmeans = KMeans(n_clusters=n_colors, random_state=0)\r\n\r\n# 处理数据\r\nchina = np.array(china, dtype=np.float64) / 255 \r\n# print(china.shape) # (427, 640, 3)\r\n# print(china) # 把数据变成0-1的区间内，方便训练\r\nw, h, d = original_shape = tuple(china.shape) # (427, 640, 3)\r\n# assert d == 3 # 断言,可不写\r\nimage_array = np.reshape(china, (w * h, d))\r\n# print(image_array.shape) # (273280, 3)\r\n# print(image_array) # 把数据变成一行一行的\r\n# 打乱数据\r\nimage_array_sample = shuffle(image_array, random_state=0)[:1000] # 可以变，但是要小于273280\r\n\r\n# 得到训练好的模型\r\nkmeans.fit(image_array_sample)\r\n\r\nlabels = kmeans.predict(image_array)\r\n# 得到了每个像素点的标签，也就是每个像素点属于哪个类别（0-63）\r\n# print(labels)\r\n\r\n# 重构图片\r\ndef recreate_image(codebook, labels, w, h):\r\n    \"\"\"从codebook和labels标签重新创建（压缩）图像\"\"\"\r\n    # 写法一，简单但需要理解reshape和数组的用法\r\n    # -1 表示自动计算维度 -- 计算出来的结果是 3\r\n    return codebook[labels].reshape(w, h, -1)\r\n    # 写法二，复杂但便于理解\r\n    # d = codebook.shape[1]\r\n    # image = np.zeros((w, h, d))# 427, 640, 3\r\n    # label_idx = 0\r\n    # for i in range(w):\r\n    #     for j in range(h):\r\n    #         image[i][j] = codebook[labels[label_idx]]\r\n    #         label_idx += 1\r\n    # return image\r\n\r\nplt.figure(2)\r\nplt.clf()\r\nplt.axis('off')\r\nplt.title('Quantized image (64 colors, K-Means)')\r\nplt.imshow(recreate_image(kmeans.cluster_centers_, labels, w, h))\r\n\r\n'''随机取'''\r\n# 打乱数据后取前64个数据\r\ncodebook_random = shuffle(image_array, random_state=0)[:n_colors]\r\n# 计算一个点和一组点之间的最小距离\r\nlabels_random = pairwise_distances_argmin(codebook_random,\r\n                                          image_array,\r\n                                          axis=0)\r\nplt.figure(3)\r\nplt.clf()\r\nplt.axis('off')\r\nplt.title('Quantized image (64 colors, Random)')\r\nplt.imshow(recreate_image(codebook_random, labels_random, w, h))",
    "level": "medium"
  },
  {
    "title": "实时分类器",
    "description": "KNN算法先记录所有已知数据，再利用一个距离函数，找出已知数据中距离未知事件最近的K组数据，最后按照这K组数据里最常见的类别预测该事件。可以解决分类问题。\r\n\r\n请编写一段程序读取用户的摄像头，让用户通过按键或点击的方式实时训练并查看当前摄像头的预测结果。",
    "python_code": "'''\r\n新建`.py`并将下方代码复制进去，确保已经安装好了下方的模块库。\r\n\r\npip install opencv-python\r\npip install tensorflow\r\n\r\n\r\n1. 等待模型加载（加载完成后会弹出摄像头）\r\n\r\n2. 按下键盘的A则获取当前摄像头截图加入A训练集\r\n\r\n3. 以此类推添加B、C训练集\r\n\r\n4. 观察屏幕输出的预测结果\r\n'''\r\nimport cv2\r\nimport tensorflow as tf\r\nfrom tensorflow.keras.applications import MobileNet\r\nfrom tensorflow.keras.preprocessing import image\r\nfrom tensorflow.keras.applications.mobilenet import preprocess_input\r\nfrom tensorflow.keras.models import Model\r\nimport numpy as np\r\n\r\n\r\nclass KNNClassifier:\r\n    def __init__(self):\r\n        self.examples = {\"A\": [], \"B\": [], \"C\": []}\r\n\r\n    def add_example(self, activation, class_id):\r\n        self.examples[class_id].append(activation)\r\n\r\n    def predict_class(self, activation):\r\n        distances = {}\r\n        for class_id, examples in self.examples.items():\r\n            distances[class_id] = np.mean(\r\n                [np.linalg.norm(act - activation) for act in examples]\r\n            )\r\n\r\n        predicted_class = min(distances, key=distances.get)\r\n        confidence = 1 / (1 + distances[predicted_class])\r\n        return predicted_class, confidence\r\n\r\n\r\ndef main():\r\n    classifier = KNNClassifier()\r\n    webcam = cv2.VideoCapture(0)\r\n\r\n    print(\"Loading MobileNet...\")\r\n    # Load the MobileNet model.\r\n    base_model = tf.keras.applications.MobileNet(weights=\"imagenet\")\r\n    model = Model(\r\n        inputs=base_model.input, outputs=base_model.get_layer(\"conv_preds\").output\r\n    )\r\n\r\n    print(\"Successfully loaded model\")\r\n\r\n    classes = [\"A\", \"B\", \"C\"]\r\n\r\n    while True:\r\n        ret, frame = webcam.read()\r\n        frame = cv2.resize(frame, (224, 224))\r\n        img = image.img_to_array(frame)\r\n        img = np.expand_dims(img, axis=0)\r\n        img = preprocess_input(img)\r\n\r\n        activation = model.predict(img)\r\n\r\n        key = cv2.waitKey(1)\r\n        if key == ord(\"a\"):\r\n            classifier.add_example(activation, \"A\")\r\n        elif key == ord(\"b\"):\r\n            classifier.add_example(activation, \"B\")\r\n        elif key == ord(\"c\"):\r\n            classifier.add_example(activation, \"C\")\r\n\r\n        if len(classifier.examples[\"A\"]) > 0:\r\n            predicted_class, confidence = classifier.predict_class(activation)\r\n            print(f\"Prediction: {predicted_class}, Confidence: {confidence}\")\r\n\r\n        cv2.imshow(\"Webcam\", frame)\r\n\r\n        if key == 27:  # ESC key to break from the loop\r\n            break\r\n\r\n    webcam.release()\r\n    cv2.destroyAllWindows()\r\n\r\n\r\nmain()",
    "level": "office"
  },
  {
    "title": "Python操作文件名",
    "description": "小明的文件夹结构为：\r\n``` bash\r\n|-docs\r\n  |- 01a.md\r\n  |- 02b.md\r\n  |- 03c.md\r\n\r\n随着知识储备增多，现在他想拓充自己的知识库,把目录结构修改为：\r\n\r\n|-docs\r\n |- 01a\r\n   |- a.md\r\n |- 02b\r\n   |- b.md\r\n |- 03c\r\n   |- c.md\r\n\r\n请你设计一个程序完成这个功能\r\n```",
    "python_code": "import os\r\n\r\npath = \"docs\"\r\n\r\nfor i in os.listdir(path):\r\n    # 读取文件夹下所有md结尾的文件\r\n    if i[-2:] == \"md\":\r\n        # 获取原文件路径\r\n        file_path = os.path.join(path, i)\r\n        # 获取要生成的文件夹路径，按自己想要的方式截取文件名作为文件夹的名字\r\n        filef_path = os.path.join(path, i[:-3])\r\n        # 创建文件夹\r\n        os.makedirs(filef_path)\r\n        # 生成移动到文件夹后的文件路径,去掉前面的2位数字，也可以用正则表达式\r\n        new_file_path = os.path.join(filef_path, i[2:])\r\n        # 移动文件：其实就是改指针\r\n        os.rename(file_path, new_file_path)\r\n\r\n# 如果后悔了想改回来\r\nimport os\r\n\r\npath = \"docs\"\r\n\r\nfor a, b, c in os.walk(path):\r\n    if c != []:\r\n        file_path = os.path.join(a, c[0])\r\n        new_file_path = a + \".md\"\r\n        os.rename(file_path, new_file_path)\r\n        os.remove(a)\r\n\r\n\r\n# 在每个文件的开头增加数据\r\nimport os\r\n\r\npath = \"docs\"\r\n\r\nfor a, b, c in os.walk(path):\r\n    if c != []:\r\n        file_path = os.path.join(a, c[0])\r\n        # r+ 可读可写\r\n        with open(file_path,'r+',encoding='utf-8') as f:\r\n            old = f.read()\r\n            f.seek(0)\r\n            f.write(\"---\\nsidebar_position: 1\\n---\\n\")\r\n            f.write(old)",
    "level": "office"
  },
  {
    "title": "Python操作表格分组聚合",
    "description": "表格样式为\r\n\r\n| code | years | name | score |\r\n| ---- | ----- | ---- | ----- |\r\n| 1    | 2019  | 小明 | 90    |\r\n| 1    | 2019  | 小红 | 80    |\r\n| 1    | 2020  | 小明 | 70    |\r\n| 1    | 2020  | 小红 | 60    |\r\n| ...   | ..  | ..| ..   |\r\n| 2    | 2019  | 小明 | 50    |\r\n\r\n请你设计一个程序完成这个功能：按name分组，生成多个表格",
    "python_code": "import pandas as pd\r\n\r\n# 分组聚合\r\ndef group(path, name):\r\n    wb = pd.read_excel(path)  # 打开excel表格\r\n    grade_df1 = wb.groupby(name)  # 按name分组\r\n    n = 1\r\n    for i in grade_df1:\r\n        writer = \"{}.xlsx\".format(n)\r\n        i[1].to_excel(writer, header=True, index=None)  # 生成表格\r\n        n += 1\r\n\r\n\r\npath = r\"data.xlsx\"\r\ngroup(path, \"years\")  # 单个标签分组\r\ngroup(path, [\"code\", \"years\"])  # 多个标签分组",
    "level": "office"
  },
  {
    "title": "复制表格样式",
    "description": "给出复制表格样式的通用方法",
    "python_code": "import copy\r\nimport openpyxl\r\nfrom openpyxl.utils import get_column_letter\r\n\r\npath = input('输入你需要复制格式的表格')\r\nsave_path = input('输入你需要复制格式后的表格路径')\r\n\r\nwb = openpyxl.load_workbook(path)\r\nwb2 = openpyxl.Workbook()\r\n\r\nsheetnames = wb.sheetnames\r\nfor sheetname in sheetnames:\r\n    print(sheetname)\r\n    sheet = wb[sheetname]\r\n    sheet2 = wb2.create_sheet(sheetname)\r\n\r\n    # 复制tab颜色\r\n    sheet2.sheet_properties.tabColor = sheet.sheet_properties.tabColor\r\n\r\n    # 开始处理合并单元格形式为“(<CellRange A1：A4>,)，替换掉(<CellRange 和 >,)' 找到合并单元格\r\n    wm = list(sheet.merged_cells)\r\n    if len(wm) > 0:\r\n        for i in range(0, len(wm)):\r\n            cell2 = str(wm[i]).replace('(<CellRange ', '').replace('>,)', '')\r\n            sheet2.merge_cells(cell2)\r\n\r\n    # 遍历后，先写入数据\r\n    for i, row in enumerate(sheet.iter_rows()):\r\n        sheet2.row_dimensions[i+1].height = sheet.row_dimensions[i+1].height\r\n        for j, cell in enumerate(row):\r\n            sheet2.column_dimensions[get_column_letter(\r\n                j+1)].width = sheet.column_dimensions[get_column_letter(j+1)].width\r\n            sheet2.cell(row=i + 1, column=j + 1, value=cell.value)\r\n\r\n            # 接着逐一设置单元格格式\r\n            source_cell = sheet.cell(i+1, j+1)\r\n            target_cell = sheet2.cell(i+1, j+1)\r\n            target_cell.fill = copy.copy(source_cell.fill)\r\n\r\n            # 默认样式是 Normal，如果是默认样式，返回False，不触发if，反之则进行复制\r\n            if source_cell.has_style: \r\n\r\n                # 该StyleableObject实现将样式存储在单个列表中_style，并且单元格上的样式属性实际上是该数组的 getter 和 setter，所以你可以使用下方的写法，克隆样式更快\r\n                target_cell._style = copy.copy(source_cell._style)\r\n\r\n                # 复制字号\r\n                target_cell.font = copy.copy(source_cell.font)\r\n\r\n                # 复制边框\r\n                target_cell.border = copy.copy(source_cell.border)\r\n\r\n                # 复制填充样式\r\n                target_cell.fill = copy.copy(source_cell.fill)\r\n\r\n                # 复制字体样式\r\n                target_cell.number_format = copy.copy(\r\n                    source_cell.number_format)\r\n\r\n                # 复制样式保护\r\n                target_cell.protection = copy.copy(source_cell.protection)\r\n\r\n                # 复制对齐样式\r\n                target_cell.alignment = copy.copy(source_cell.alignment)\r\n\r\nif 'Sheet' in wb2.sheetnames:\r\n    del wb2['Sheet']\r\nwb2.save(save_path)\r\n\r\nwb.close()\r\nwb2.close()",
    "level": "office"
  },
  {
    "title": "图片转方图并切成九宫格",
    "description": "给出图片转方图并切成九宫格的通用方法",
    "python_code": "'''\r\n转方图并切成九宫格\r\n'''\r\nfrom PIL import Image\r\nimport sys\r\nimport winreg\r\nimport os\r\n#将图片填充为正方形\r\ndef fill_image(image):\r\n    width, height = image.size\r\n    #选取长和宽中较大值作为新图片的\r\n    new_image_length = width if width > height else height\r\n    #生成新图片[白底]\r\n    new_image = Image.new(image.mode, (new_image_length, new_image_length), color='white')\r\n    #将之前的图粘贴在新图上，居中\r\n    if width > height:#原图宽大于高，则填充图片的竖直维度\r\n        new_image.paste(image, (0, int((new_image_length - height) / 2)))#(x,y)二元组表示粘贴上图相对下图的起始位置\r\n    else:\r\n        new_image.paste(image, (int((new_image_length - width) / 2),0))\r\n    return new_image\r\n#切图\r\ndef cut_image(image):\r\n    width, height = image.size\r\n    item_width = int(width / 3)\r\n    box_list = []\r\n    # (left, upper, right, lower)\r\n    for i in range(0,3):\r\n        for j in range(0,3):\r\n            #print((i*item_width,j*item_width,(i+1)*item_width,(j+1)*item_width))\r\n            box = (j*item_width,i*item_width,(j+1)*item_width,(i+1)*item_width)\r\n            box_list.append(box)\r\n    \r\n    image_list = [image.crop(box) for box in box_list]\r\n\r\n    return image_list\r\n#保存\r\ndef save_images(image_list):\r\n    Desktoppath = winreg.QueryValueEx(winreg.OpenKey(winreg.HKEY_CURRENT_USER,r'Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders'), \"Desktop\")[0]#获取电脑系统桌面路径\r\n    os.makedirs(Desktoppath+\"\\\\result\") #创建一个文件夹\r\n    newfiledirs = Desktoppath+\"\\\\result\"\r\n    index = 1\r\n    for image in image_list:\r\n        image.save(newfiledirs+\"\\\\\"+str(index) + '.png', 'PNG')\r\n        index += 1\r\n        \r\nif __name__ == '__main__':\r\n    文件路径 = input('请输入你的转化的文件路径（别忘了加文件后缀名哦）：')\r\n    image = Image.open(文件路径)#放入图片路径\r\n    image = fill_image(image) #填充\r\n    image_list = cut_image(image) #切割\r\n    save_images(image_list) #保存",
    "level": "office"
  },
  {
    "title": "图片拼接",
    "description": "给出图片拼接的通用方法",
    "python_code": "'''\r\n图片拼接\r\n'''\r\n\r\n# encoding: utf-8\r\ndef merge_LR(pics): #左右拼接\r\n    from imageio import imread\r\n    import skimage.io as io\r\n    import numpy as np\r\n    A_wordcould_path = 'wordcould1.png'#合并后图片的名字\r\n    #横向拼接\r\n    图片1 = io.imread(pics[0])   # np.ndarray, [h, w, c], 值域(0, 255), RGB\r\n    图片2 = io.imread(pics[1])   # np.ndarray, [h, w, c], 值域(0, 255), RGB\r\n    #print(图片1.dtype)\r\n    图片1_h = 图片1.shape[0]   #查看图片的大小\r\n    图片1_w = 图片1.shape[1]\r\n    图片1_c = 图片1.shape[2]\r\n    图片2_h = 图片2.shape[0]   #查看图片的大小\r\n    图片2_w = 图片2.shape[1]\r\n    if 图片1_h >= 图片2_h :\r\n        pj1 = np.zeros((图片1_h,图片1_w+图片2_w,图片1_c))   #横向拼接\r\n    else:\r\n        pj1 = np.zeros((图片2_h,图片1_w+图片2_w,图片1_c))  #横向拼接\r\n    pj1[:,:图片1_w,:] = 图片1.copy()   #图片图片1在左\r\n    pj1[:,图片2_w:,:] = 图片2.copy()   #图片图片2在右\r\n    pj1=np.array(pj1,dtype=np.uint8)   #将pj1数组元素数据类型的改为\"uint8\"\r\n    io.imsave(A_wordcould_path, pj1)   #保存拼接后的图片\r\n\r\ndef merge_UD(pics): #上下拼接\r\n    from imageio import imread\r\n    import skimage.io as io\r\n    import numpy as np\r\n    B_wordcould_path = 'wordcould2.png'\r\n    # 上面与下面拼接\r\n    图片1 = io.imread(pics[0])   # np.ndarray, [h, w, c], 值域(0, 255), RGB\r\n    图片2 = io.imread(pics[1])   # np.ndarray, [h, w, c], 值域(0, 255), RGB\r\n    图片1_h = 图片1.shape[0]   #查看图片的大小\r\n    图片1_w = 图片1.shape[1]\r\n    图片1_c = 图片1.shape[2]\r\n    图片2_h = 图片2.shape[0]   #查看图片的大小\r\n    图片2_w = 图片2.shape[1]\r\n    if 图片1_w >= 图片2_w :\r\n        pj = np.zeros((图片1_h+图片2_h,图片1_w,图片1_c))   #竖向拼接\r\n    else:\r\n        pj = np.zeros((图片2_h+图片2_h,图片2_w,图片1_c))  #竖向拼接\r\n    #计算最终图片的像素大小\r\n    pj[:图片1_h,:,:] = 图片1.copy()   #图片图片1在左\r\n    pj[图片2_h:,:,:] = 图片2.copy()   #图片图片2在右\r\n    pj=np.array(pj,dtype=np.uint8)   #将pj数组元素数据类型的改为\"uint8\"\r\n    io.imsave(B_wordcould_path, pj)   #保存拼接后的图片\r\n\r\npics = ['3.png','4.png']\r\nmerge_LR(pics) #左右\r\n#merge_UD(pics)#上下",
    "level": "office"
  },
  {
    "title": "ipynb合并",
    "description": "给出ipynb合并的通用方法",
    "python_code": "# 合并文件夹下所有ipynb文件\r\ndef merge_ipynb(wpt):\r\n    if wpt.endswith(\"/\"):\r\n        return\r\n    else:\r\n        wpt = wpt + \"/\"\r\n    path = wpt[:-1]\r\n\r\n    for root, dirs, files in os.walk(wpt):\r\n        flst = files\r\n    flst = [wpt + f for f in flst if f.endswith(\".ipynb\")]\r\n    jmain = json.load(open(flst[0], \"r\", encoding=\"utf-8\"))\r\n    for f in flst[1:]:\r\n        jn = json.load(open(f, \"r\", encoding=\"utf-8\"))\r\n        jmain[\"cells\"].extend(jn[\"cells\"])\r\n\r\n    with open(\"{}.ipynb\".format(path), \"w\", encoding=\"utf-8\") as wf:\r\n        json.dump(jmain, wf)  # 写入文件",
    "level": "office"
  },
  {
    "title": "ipynb转md",
    "description": "给出ipynb转md的通用方法",
    "python_code": "# ipynb转md\r\ndef ipynb2md(wpt, save_path=\"\"):\r\n    md_file_name = os.path.join(save_path, wpt.replace(\".ipynb\", \".md\"))\r\n    file_name = wpt.split(\"\\\\\")[-1].split(\".\")[0]\r\n\r\n    try:\r\n        print(wpt)\r\n        ja = json.load(open(wpt, \"r\", encoding=\"utf-8\"))\r\n        md_str = \"\"  # 两种模式：直接装到一个字符串里或装到列表里，一行是一个字符串\r\n\r\n        for c in ja[\"cells\"]:\r\n            if c[\"cell_type\"] == \"markdown\":\r\n                md_str = md_str + \"\\n\" + \"\".join(c[\"source\"]) + \"\\n\\n\"\r\n            elif c[\"cell_type\"] == \"code\":\r\n                md_str = md_str + \"\\n",
    "level": "office"
  },
  {
    "title": "拆合PDF",
    "description": "给出PDF的拆分与合并的通用方法",
    "python_code": "from PyPDF2 import PdfFileWriter, PdfFileReader, PdfFileMerger\r\nimport os\r\nfrom PyPDF2 import PdfFileReader, PdfFileMerger\r\n\r\n\r\ndef get_reader(filename, password):\r\n    try:\r\n        old_file = open(filename, \"rb\")\r\n    except IOError as err:\r\n        print(\"文件打开失败！\" + str(err))\r\n        return None\r\n\r\n    pdf_reader = PdfFileReader(old_file, strict=False)  # 创建读实例\r\n    # 解密操作\r\n    if pdf_reader.isEncrypted:\r\n        if password is None:\r\n            print(\"%s文件被加密，需要密码！\" % filename)\r\n            return None\r\n        else:\r\n            if pdf_reader.decrypt(password) != 1:\r\n                print(\"%s密码不正确！\" % filename)\r\n                return None\r\n    if old_file in locals():\r\n        old_file.close()\r\n    return pdf_reader\r\n\r\n\r\ndef encrypt_pdf(filename, new_password, old_password=None, encrypted_filename=None):\r\n    \"\"\"对filename所对应的文件进行加密,并生成一个新的文件\r\n    :param filename: 文件对应的路径\r\n    :param new_password: 对文件加密使用的密码\r\n    :param old_password: 如果旧文件进行了加密，需要密码\r\n    :param encrypted_filename: 加密之后的文件名，省却时使用filename_encrypted;\r\n    :return:\"\"\"\r\n\r\n    pdf_reader = get_reader(filename, old_password)  # 创建一个Reader实例\r\n    if pdf_reader is None:\r\n        return\r\n    pdf_writer = PdfFileWriter()  # 创建一个写操作的实例\r\n    pdf_writer.appendPagesFromReader(pdf_reader)  # 从之前Reader中将数据写入到Writer中\r\n    pdf_writer.encrypt(new_password)  # 重新使用新密码加密\r\n    if encrypted_filename is None:\r\n        encrypted_filename = (\r\n            \"\".join(filename.split(\".\")[:-1]) + \"_\" + \"encrypted\" + \".pdf\"\r\n        )  # 使用旧文件名 + encrypted 作为新的文件名\r\n    pdf_writer.write(open(encrypted_filename, \"wb\"))\r\n\r\n\r\ndef decrypt_pdf(filename, password, decrypted_filename=None):\r\n    \"\"\"将加密的文件及逆行解密，并生成一个无需密码pdf文件\r\n    :param filename: 原先加密的pdf文件\r\n    :param password: 对应的密码\r\n    :param decrypted_filename: 解密之后的文件名\r\n    :return:\"\"\"\r\n    pdf_reader = get_reader(filename, password)  # 生成一个Reader和Writer\r\n    if pdf_reader is None:\r\n        return\r\n    if not pdf_reader.isEncrypted:\r\n        print(\"文件没有被加密，无需操作！\")\r\n        return\r\n    pdf_writer = PdfFileWriter()\r\n    pdf_writer.appendPagesFromReader(pdf_reader)\r\n    if decrypted_filename is None:\r\n        decrypted_filename = (\r\n            \"\".join(filename.split(\".\")[:-1]) + \"_\" + \"decrypted\" + \".pdf\"\r\n        )\r\n    pdf_writer.write(open(decrypted_filename, \"wb\"))  # 写入新文件\r\n\r\n\r\ndef split_by_pages(filename, pages, password=None):\r\n    \"\"\"将文件按照页数进行平均分割\r\n    :param filename: 所要分割的文件名\r\n    :param pages: 分割之后每个文件对应的页数\r\n    :param password: 如果文件加密，需要进行解密操作\r\n    :return:\"\"\"\r\n    pdf_reader = get_reader(filename, password)  # 得到Reader\r\n    if pdf_reader is None:\r\n        return\r\n    pages_nums = pdf_reader.numPages  # 得到总的页数\r\n    if pages <= 1:\r\n        print(\"每份文件必须大于1页！\")\r\n        return\r\n    pdf_num = (\r\n        pages_nums // pages + 1 if pages_nums % pages else int(pages_nums / pages)\r\n    )  # 得到切分之后每个pdf文件的页数\r\n    print(\"pdf文件被分为%d份，每份有%d页！\" % (pdf_num, pages))\r\n    for cur_pdf_num in range(1, pdf_num + 1):  # 依次生成pdf文件\r\n        pdf_writer = PdfFileWriter()  # 创建一个新的写实例\r\n        split_pdf_name = (\r\n            \"\".join(filename)[:-1] + \"_\" + str(cur_pdf_num) + \".pdf\"\r\n        )  # 生成对应的文件名称\r\n        start = pages * (cur_pdf_num - 1)  # 计算出当前开始的位置\r\n        end = (\r\n            pages * cur_pdf_num if cur_pdf_num != pdf_num else pages_nums\r\n        )  # 计算出结束的位置，如果是最后一份就直接返回最后的页数，否则用每份页数*已经分好的文件数\r\n        # print(str(start) + ',' + str(end))\r\n        for i in range(start, end):  # 依次读取对应的页数\r\n            pdf_writer.addPage(pdf_reader.getPage(i))\r\n        pdf_writer.write(open(split_pdf_name, \"wb\"))  # 写入文件\r\n\r\n\r\ndef split_by_num(filename, nums, password=None):\r\n    \"\"\"将pdf文件分为nums份\r\n    :param filename: 文件名\r\n    :param nums: 要分成的份数\r\n    :param password: 如果需要解密，输入密码\r\n    :return:\"\"\"\r\n    pdf_reader = get_reader(filename, password)\r\n    if not pdf_reader:\r\n        return\r\n    if nums < 2:\r\n        print(\"份数不能小于2！\")\r\n        return\r\n    pages = pdf_reader.numPages  # 得到pdf的总页数\r\n    if pages < nums:\r\n        print(\"份数不应该大于pdf总页数！\")\r\n        return\r\n    each_pdf = pages // nums  # 计算每份应该有多少页\r\n    print(\"pdf共有%d页，分为%d份，每份有%d页！\" % (pages, nums, each_pdf))\r\n\r\n    for num in range(1, nums + 1):\r\n        pdf_writer = PdfFileWriter()  # 生成对应的文件名称\r\n        split_pdf_name = \"\".join(filename)[:-1] + \"_\" + str(num) + \".pdf\"  # 计算出当前开始的位置\r\n        start = each_pdf * (num - 1)  # 计算出结束的位置，如果是最后一份就直接返回最后的页数，否则用每份页数*已经分好的文件数\r\n        end = each_pdf * num if num != nums else pages\r\n        print(str(start) + \",\" + str(end))\r\n        for i in range(start, end):\r\n            pdf_writer.addPage(pdf_reader.getPage(i))\r\n        pdf_writer.write(open(split_pdf_name, \"wb\"))\r\n\r\n\r\ndef merger_pdf(filenames, merged_name, passwords=None):\r\n    \"\"\"传进来一个文件列表，将其依次融合起来\r\n    :param filenames: 文件列表\r\n    :param passwords: 对应的密码列表\r\n    :return:\"\"\"\r\n    filenums = len(filenames)  # 计算共有多少文件\r\n    pdf_merger = PdfFileMerger(False)  # 注意需要使用False 参数\r\n    for i in range(filenums):\r\n        if passwords is None:  # 得到密码\r\n            password = None\r\n        else:\r\n            password = passwords[i]\r\n        pdf_reader = get_reader(filenames[i], password)\r\n        if not pdf_reader:\r\n            return\r\n        pdf_merger.append(pdf_reader)  # append默认添加到最后\r\n    pdf_merger.write(open(merged_name, \"wb\"))\r\n\r\n\r\ndef insert_pdf(pdf1, pdf2, insert_num, merged_name, password1=None, password2=None):\r\n    \"\"\"将pdf2全部文件插入到pdf1中第insert_num页\r\n    :param pdf1: pdf1文件名称\r\n    :param pdf2: pdf2文件名称\r\n    :param insert_num: 插入的页数\r\n    :param merged_name: 融合后的文件名称\r\n    :param password1: pdf1对应的密码\r\n    :param password2: pdf2对应的密码\r\n    :return:\"\"\"\r\n    pdf1_reader = get_reader(pdf1, password1)\r\n    pdf2_reader = get_reader(pdf2, password2)\r\n    if not pdf1_reader or not pdf2_reader:  # 如果有一个打不开就返回\r\n        return\r\n    pdf1_pages = pdf1_reader.numPages  # 得到pdf1的总页数\r\n    if insert_num < 0 or insert_num > pdf1_pages:\r\n        print(\"插入位置异常，想要插入的页数为：%d，pdf1文件共有：%d页！\" % (insert_num, pdf1_pages))\r\n        return\r\n    m_pdf = PdfFileMerger(False)  # 注意需要使用False参数，可能会出现中文乱码的情况\r\n    m_pdf.append(pdf1)\r\n    m_pdf.merge(insert_num, pdf2)\r\n    m_pdf.write(open(merged_name, \"wb\"))\r\n\r\n\r\ndef auto_input(path,result_name): #合并PDF为一份\r\n    result_pdf= PdfFileMerger() #新建实例对象\r\n    for pdf in os.listdir(path):  #遍历文件夹\r\n        with open (pdf,'rb') as fp:  # 打开要合并的子PDF\r\n            pdf_reder = PdfFileReader(fp)  #读取PDF内容\r\n            if pdf_reder.isEncrypted:   # 判断是否被加密\r\n                print(f'忽略加密文件：{pdf}')  # 如果加密则跳过，并打印忽略加密文件\r\n                continue\r\n            result_pdf.append(pdf_reder,import_bookmarks = True) # 将刚刚读取到的PDF内容追加到实例对象内\r\n    result_pdf.write(result_name) # 写入保存\r\n    result_pdf.close()    # 关闭程序\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    # 加密\r\n    # encrypt_pdf('ex1.pdf', 'leafage')\r\n\r\n    # 解密\r\n    # decrypt_pdf('ex1123_encrypted.pdf', 'leafage')\r\n\r\n    # 按页数拆分\r\n    # split_by_pages('ex1.pdf', 5)\r\n\r\n    # 按拆分后的文件数拆分\r\n    split_by_num(\"示例.pdf\", 2)\r\n\r\n    # 合并PDF文件\r\n    # merger_pdf(['ex1.pdf', 'ex2.pdf'], 'merger.pdf')\r\n\r\n    # 插入PDF至指定位置\r\n    # insert_pdf('ex1.pdf', 'ex2.pdf', 10, 'pdf12.pdf')",
    "level": "office"
  },
  {
    "title": "PDF添加水印",
    "description": "PDF添加水印",
    "python_code": "'''\r\n- 准备添加水印的物料放置于同级「初始物料」文件夹内\r\n- 准备好的水印文件放置于同级「水印文件」文件夹内（仅限1张水印文件）\r\n- 若修改了水印文件，需要将最后一行调用create_watermark函数的watermark参数进行调整\r\n\r\n文件结构如下\r\n|- 此py文件\r\n|- 初始物料\r\n  |- 你要添加水印的文件.pdf\r\n  |- 你要添加水印的文件2.pdf\r\n  |- 你要添加水印的文件3.pdf\r\n|- 水印文件\r\n  |- 水印.pdf\r\n|- 水印版物料\r\n'''\r\nimport os\r\nfrom PyPDF2 import PdfFileWriter, PdfFileReader\r\n\r\n# 添加水印功能的函数\r\n\r\n\r\ndef create_watermark(input_pdf, output_pdf, watermark):\r\n    # 获取水印\r\n    watermark_obj = PdfFileReader(watermark, strict=False)\r\n    watermark_page = watermark_obj.getPage(0)\r\n\r\n    # 创建读取对象和写入对象\r\n    pdf_reader = PdfFileReader(input_pdf, strict=False)\r\n    pdf_writer = PdfFileWriter()\r\n\r\n    # 给所有页面添加水印，并新建pdf文件\r\n    for page in range(pdf_reader.getNumPages()):\r\n        page = pdf_reader.getPage(page)\r\n        page.mergePage(watermark_page)\r\n        pdf_writer.addPage(page)\r\n\r\n    with open(output_pdf, 'wb') as out:\r\n        pdf_writer.write(out)\r\n\r\n\r\nif __name__ == '__main__':\r\n    # 筛选pdf物料，并执行添加水印功能的函数\r\n    # 代码中的文件路径均使用相对路径，因此在运行时需要注意文件当前层级，以免运行出错\r\n    pdf_file_path = './初始物料'\r\n    pdf_files = os.listdir(pdf_file_path)\r\n    for pdf_file in pdf_files:\r\n        if pdf_file[-3:] == 'pdf':\r\n            input_pdf = pdf_file_path + '/' + pdf_file\r\n            output_pdf = './水印版物料/'+pdf_file[0:-3]+'pdf'\r\n            create_watermark(\r\n                input_pdf=input_pdf, output_pdf=output_pdf, watermark='./水印文件/编程水印.pdf')",
    "level": "office"
  },
  {
    "title": "PDF转WORD",
    "description": "PDF转WORD",
    "python_code": "from pdf2docx import Converter\r\npdf_file = input('请输入pdf文件路径:')\r\ndocx_file = input('请输入转换后的word文件的路径:')\r\ncv = Converter(pdf_file)# 实例化 Converter 类并传入pdf文件的路径\r\ncv.convert(docx_file, start=0, end=None)# 调用 convert 方法转换为 word文件,start参数为起始页,end为终止页\r\ncv.close()\r\n\r\n#纯文字+图片的PDF识别效果最好，超链接等其他格式将不被保留",
    "level": "office"
  },
  {
    "title": "万物转PDF",
    "description": "给出通用的'doc', 'docx', 'ppt', 'pptx', 'xls', 'xls 转PDF的方法",
    "python_code": "import os\r\nfrom pathlib import Path\r\nfrom win32com.client import Dispatch, gencache, DispatchEx\r\nimport win32com.client\r\n# 定义类\r\n\r\n\r\nclass PDFConverter:\r\n    def __init__(self, pathname):\r\n        self._handle_postfix = ['doc', 'docx', 'ppt', 'pptx', 'xls', 'xlsx']\r\n        self._filename_list = list()\r\n        self._export_folder = os.path.join(os.path.abspath('.'), outpath)\r\n        if not os.path.exists(self._export_folder):\r\n            os.mkdir(self._export_folder)\r\n        self._enumerate_filename(pathname)\r\n\r\n    def _enumerate_filename(self, pathname):\r\n        full_pathname = os.path.abspath(pathname)\r\n        if os.path.isfile(full_pathname):\r\n            if self._is_legal_postfix(full_pathname):\r\n                self._filename_list.append(full_pathname)\r\n            else:\r\n                raise TypeError('文件 {} 后缀名不合法！仅支持如下文件类型：{}。'.format(\r\n                    pathname, '、'.join(self._handle_postfix)))\r\n        elif os.path.isdir(full_pathname):\r\n            for relpath, _, files in os.walk(full_pathname):\r\n                for name in files:\r\n                    filename = os.path.join(full_pathname, relpath, name)\r\n                    if self._is_legal_postfix(filename):\r\n                        self._filename_list.append(os.path.join(filename))\r\n        else:\r\n            raise TypeError('文件/文件夹 {} 不存在或不合法！'.format(pathname))\r\n\r\n    def _is_legal_postfix(self, filename):\r\n        return filename.split('.')[-1].lower() in self._handle_postfix and not os.path.basename(filename).startswith('~')\r\n\r\n    def run_conver(self):\r\n        '''\r\n        进行批量处理，根据后缀名调用函数执行转换\r\n        '''\r\n        print('需要转换的文件数：', len(self._filename_list))\r\n        for filename in self._filename_list:\r\n            postfix = filename.split('.')[-1].lower()\r\n            funcCall = getattr(self, postfix)\r\n            print('原文件：', filename)\r\n            funcCall(filename)\r\n        print('转换完成！')\r\n\r\n    def doc(self, filename):\r\n        '''\r\n        doc 和 docx 文件转换\r\n        '''\r\n        name = os.path.basename(filename).split('.')[0] + '.pdf'\r\n        word = Dispatch('Word.Application')\r\n        doc = word.Documents.Open(filename)\r\n        pdf_file = os.path.join(self._export_folder, name)\r\n        doc.SaveAs(pdf_file, FileFormat=17)\r\n        doc.Close()\r\n        word.Quit()\r\n\r\n    def docx(self, filename):\r\n        self.doc(filename)\r\n\r\n    def xls(self, filename):\r\n        '''\r\n        xls 和 xlsx 文件转换\r\n        '''\r\n        name = os.path.basename(filename).split('.')[0] + '.pdf'\r\n        exportfile = os.path.join(self._export_folder, name)\r\n        xlApp = DispatchEx(\"Excel.Application\")\r\n        xlApp.Visible = False\r\n        xlApp.DisplayAlerts = 0\r\n        books = xlApp.Workbooks.Open(filename, False)\r\n        books.ExportAsFixedFormat(0, exportfile)\r\n        books.Close(False)\r\n        print('保存 PDF 文件：', exportfile)\r\n        xlApp.Quit()\r\n\r\n    def xlsx(self, filename):\r\n        self.xls(filename)\r\n\r\n    def ppt(self,filename):\r\n        \"\"\"\r\n        PPT文件导出为pdf格式\r\n        :param filename: PPT文件的名称\r\n        :param output_filename: 导出的pdf文件的名称\r\n        :return:\r\n        \"\"\"\r\n        name = os.path.basename(filename).split('.')[0] + '.pdf'\r\n        exportfile = os.path.join(self._export_folder, name)\r\n        ppt_app = win32com.client.Dispatch('PowerPoint.Application')\r\n        ppt = ppt_app.Presentations.Open(filename)\r\n        ppt.SaveAs(exportfile, 32)\r\n        print('保存 PDF 文件：', exportfile)\r\n        ppt_app.Quit()\r\n\r\n    def pptx(self, filename):\r\n        self.ppt(filename)\r\n\r\n\r\ndef main(In_Path):\r\n    my_file = Path(In_Path)\r\n    if my_file.is_dir():  # 判断是否为文件夹\r\n        pathname = os.path.join(os.path.abspath('.'), In_Path)\r\n    else:\r\n        pathname = In_Path  # 单个文件的转换\r\n    pdfConverter = PDFConverter(pathname)\r\n    pdfConverter.run_conver()\r\n\r\nif __name__ == \"__main__\":\r\n    outpath = '转化后'\r\n    main(input('输入你要转化的文件或文件夹路径'))",
    "level": "office"
  },
  {
    "title": "修改word文件",
    "description": "修改word文件",
    "python_code": "import docx\r\nimport os\r\n\r\n\r\ndef replace_words(path, old, new):\r\n    \"\"\"\r\n    :param path:文件路径\r\n    :param old:需要替换的keyword\r\n    :param new:新的替换后的keyword\r\n    \"\"\"\r\n    if path.endswith(\".docx\"):\r\n        # 不支持读取doc格式的文件\r\n        doc = docx.Document(path)\r\n        for paragraph in doc.paragraphs:\r\n            for run in paragraph.runs:\r\n                if run.text:\r\n                    run.text = run.text.replace(old, new)\r\n            doc.save(path)\r\n    else:\r\n        raise ValueError(\"只支持docx文件格式!\")\r\n\r\n\r\nif __name__ == '__main__':\r\n    dir_path = './replace_word_keyword'\r\n    old_keyword = \"AI\"\r\n    new_keyword = \"人工智能\"\r\n    files = os.listdir(path=dir_path)\r\n    for file in files:\r\n        try:\r\n            replace_words(os.path.join(dir_path, file), old_keyword, new_keyword)\r\n            print(\"{}已经修改成功\".format(file))\r\n        except ValueError as e:\r\n            print(\"{}发生如下错误\\n{}\".format(file, e))",
    "level": "office"
  },
  {
    "title": "更改Word方向",
    "description": "更改Word方向",
    "python_code": "import docx\r\nimport os\r\n\r\ndef change_forward(word_path, result_path):\r\n    '''\r\n    改变word文档的方向\r\n    :param word_path: word路径\r\n    '''\r\n    # 创建保存路径\r\n    if not os.path.exists(result_path):\r\n        os.makedirs(result_path)\r\n    doc = docx.Document(word_path)\r\n    for section in doc.sections:\r\n        # 交替宽高\r\n        section.page_width,section.page_height = section.page_height ,section.page_width\r\n    # 保存为新文件\r\n    doc.save(os.path.join(result_path,word_path)) \r\n \r\nif __name__ == '__main__':\r\n\r\n    #获取文件夹下的word文档列表,路径自定义\r\n    path = 'path'\r\n    spam=os.listdir(path)\r\n    os.chdir(path)\r\n    for i in spam:\r\n        if i.endswith('.docx'):\r\n            change_forward(str(i),'new')",
    "level": "office"
  },
  {
    "title": "提取Word内图片",
    "description": "提取Word内图片",
    "python_code": "import docx,os, re,cv2\r\nimport numpy as np\r\n\r\ndef get_pictures(word_path, result_path):\r\n    \"\"\"\r\n    图片提取\r\n    :param word_path: word路径\r\n    :result_path: 保存路径\r\n    :return: \r\n    \"\"\"\r\n    # 创建保存路径\r\n    if not os.path.exists(result_path):\r\n        os.makedirs(result_path)\r\n    # 读取文件\r\n    doc = docx.Document(word_path)\r\n\r\n    # 获取图片\r\n    dict_rel = doc.part._rels\r\n    for rel in dict_rel:\r\n        rel = dict_rel[rel]\r\n        if \"image\" in rel.target_ref:            \r\n            img_name = re.findall(\"/(.*)\", rel.target_ref)[0]\r\n            word_name = os.path.splitext(word_path)[0]\r\n            if os.sep in word_name:\r\n                new_name = word_name.split('\\\\')[-1]\r\n            else:\r\n                new_name = word_name.split('/')[-1]\r\n            # cv2获取图片大小\r\n            imgdata = np.frombuffer(rel.target_part.blob,np.uint8)\r\n            img_cv = cv2.imdecode(imgdata,cv2.IMREAD_ANYCOLOR)\r\n            img_name = '{}-{}-{}-{}'.format(new_name,img_cv.shape[0],img_cv.shape[1],img_name)\r\n            # 直接二进制写入兼容性比使用CV2的保存图片好\r\n            with open(f'{result_path}/{img_name}','wb') as f:\r\n                f.write(rel.target_part.blob)\r\n        else:\r\n            pass\r\n \r\nif __name__ == '__main__':\r\n\r\n    #获取文件夹下的word文档列表,路径自定义\r\n    path = '第二章 创享Robot'\r\n    spam=os.listdir(path)\r\n    os.chdir(path)\r\n    for i in spam:\r\n        if i.endswith('.docx'):\r\n            get_pictures(str(i),os.getcwd())",
    "level": "office"
  },
  {
    "title": "解析二维码",
    "description": "将二维码图片解析为它的结果",
    "python_code": "from easyqr import easyqr as qr# 解析模块\r\n#上传图片\r\npath = 'ME.png'#使用你自己的微信二维码截图即可\r\nurl = qr.upload(path)\r\n#获得解析的地址\r\nurl =qr.online(url)",
    "level": "office"
  },
  {
    "title": "生成二维码",
    "description": "生成二维码",
    "python_code": "from MyQR import myqr #动态二维码模块，结果不支持中文\r\nmyqr.run(\r\n    words= str(url)          ,  # 扫描二维码后，显示的内容，或是跳转的链接\r\n    version=9                ,  # 设置容错率\r\n    level='L'                ,  # 控制纠错水平，范围是L、M、Q、H，从左到右依次升高\r\n    picture='gif.gif' ,  # 图片所在目录，可以是动图\r\n    colorized=True           ,  # 黑白(False)还是彩色(True)\r\n    contrast=1.0             ,  # 用以调节图片的对比度，1.0 表示原始图片。默认为1.0。\r\n    brightness=1.0           ,  # 用来调节图片的亮度，用法同上。\r\n    save_name='xxxxx.gif'        ,  # 控制输出文件名，格式可以是 .jpg， .png ，.bmp ，.gif\r\n    )\r\n\r\nimport qrcode #静态二维码模块，支持中文\r\nimg = qrcode.make('DESKTOP')# 填写你想要扫码出现的内容（文字/链接）\r\nimg.save('DESKTOP.png') # 填写文件保存路径",
    "level": "office"
  },
  {
    "title": "发送邮件",
    "description": "发送邮件\r\n定时任务。\r\n增加附件与附图\r\n\r\n说明：需要先开启两个服务：\r\nIMAP/SMTP服务已开启\r\nPOP3/SMTP服务已开启",
    "python_code": "import time,schedule\r\nfrom smtplib import SMTP_SSL, SMTP\r\nfrom email.mime.text import MIMEText\r\nfrom email.mime.multipart import MIMEMultipart\r\nfrom email.mime.image import MIMEImage\r\n\r\ndef send_mail(message, Subject, sender_show, recipient_show, to_addrs,filelanguage = 'cn',filepath=None,imagepath=None, cc_show=''):\r\n    \"\"\"\r\n    :param message: str 邮件内容\r\n    :param Subject: str 邮件主题描述\r\n    :param sender_show: str 发件人显示，不起实际作用如：\"xxx\"\r\n    :param recipient_show: str 收件人显示，不起实际作用 多个收件人用','隔开如：\"xxx,xxxx\"\r\n    :param to_addrs: str 实际收件人\r\n    :param cc_show: str 抄送人显示，不起实际作用，多个抄送人用','隔开如：\"xxx,xxxx\"\r\n    \"\"\"\r\n    # 填写真实的发邮件服务器用户名、密码\r\n    user = 'xxx@126.com'\r\n    password = 'xxx'\r\n    #发送附件的方法定义为一个变量\r\n    msg=MIMEMultipart()                             \r\n    # 邮件内容\r\n    content='邮件正文' \r\n    #发送正文\r\n    msg.attach(MIMEText(content,'html', 'utf-8'))  \r\n    #调用传送附件模块，传送附件\r\n    if filepath != None:\r\n        att=MIMEText(open(filepath,'rb').read(),'base64','utf-8')    \r\n        #修改下方filename为文件名（文本型，不支持中文）\r\n        att[\"Content-Type\"]='application/octet-stream' \r\n        if filelanguage == 'cn':\r\n            show_file_name = '中文附件.xlsx' # 填写你希望展示出来的附件名称\r\n            att.add_header(\"Content-Disposition\", \"attachment\", filename=(\"gbk\", \"\", show_file_name))\r\n        else:\r\n            show_file_name = 'English.XLSX' # 填写你希望展示出来的附件名称\r\n            att[\"Content-Disposition\"]=f'attachment;filename=\"{show_file_name}\"' \r\n        \r\n        msg.attach(att)#发送附件\r\n\r\n    if imagepath != None:\r\n        #批量添加图片时需要修改值\r\n        mime_images = '<p><img src=\"cid:imageid{0}\" alt=\"imageid{0}\"></p>'.format(1)\r\n        mime_img = MIMEImage(open(imagepath, 'rb').read(), _subtype='octet-stream')\r\n        mime_img.add_header('Content-ID', 'imageid')\r\n        #上传图片至缓存空间\r\n        msg.attach(mime_img)\r\n        # 上传正文\r\n        mime_html = MIMEText('<html><body><p>{0}</p>{1}</body></html>'.format('', mime_images), 'html', 'utf-8')\r\n        # 添加附图至正文\r\n        msg.attach(mime_html)\r\n\r\n    # 邮件主题描述\r\n    msg[\"Subject\"] = Subject\r\n    # 发件人显示，不起实际作用\r\n    msg[\"from\"] = sender_show\r\n    # 收件人显示，不起实际作用\r\n    msg[\"to\"] = recipient_show\r\n    # 抄送人显示，不起实际作用\r\n    msg[\"Cc\"] = cc_show\r\n    try:\r\n        with SMTP_SSL(host=\"smtp.126.com\", port=465) as smtp:\r\n            # 登录发邮件服务器\r\n            smtp.login(user=user, password=password)\r\n            # 实际发送、接收邮件配置\r\n            smtp.sendmail(from_addr=user, to_addrs=to_addrs.split(','), msg=msg.as_string())\r\n            print('send ok.')\r\n    except Exception as e:\r\n        print(\"send error.\", e)\r\n\r\n\r\n\r\n\r\nif __name__ == '__main__':\r\n    message = 'Python 测试邮件...'\r\n    Subject = '主题测试'\r\n    # 显示发送人\r\n    sender_show = 'xxx'\r\n    # 显示收件人\r\n    recipient_show = 'xxx'\r\n    # 实际发给的收件人\r\n    to_addrs = 'xxx@qq.com,'\r\n    def job():\r\n        send_mail(message, Subject, sender_show, recipient_show, to_addrs)\r\n\r\n    # 每隔10分钟执行一次任务\r\n    # schedule.every(10).minutes.do(job)\r\n    # 每隔一小时执行一次任务\r\n    # schedule.every().hour.do(job)\r\n    # 每天10:30执行一次任务\r\n    # schedule.every().day.at(\"10:30\").do(job)\r\n    # 每周一的这个时候执行一次任务\r\n    # schedule.every().monday.do(job)\r\n    # 每周三13:15执行一次任务\r\n    # schedule.every().wednesday.at(\"13:15\").do(job)\r\n    # 每周五18：00执行一次任务\r\n    schedule.every().friday.at(\"18:00\").do(job)\r\n    while True:\r\n        schedule.run_pending()\r\n        time.sleep(1)",
    "level": "office"
  }
]